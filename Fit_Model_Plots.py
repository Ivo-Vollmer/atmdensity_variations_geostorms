"""@author: ivovollmer"""import syssys.path.append('PATHTOCODEFUNCTIONS')from gauss_func import *from import_files import *from functions_final import *from fit_model_error import *from offset_function_updated import *from math import *import numpy as npfrom scipy.fft import rfft, rfftfreqfrom scipy.signal import savgol_filterfrom scipy.signal import find_peaksimport matplotlib.pyplot as plt##################################################################################################################################data_weather_2024 = load_all_data("PATHDSTINDEXDATA", 1, 1, csv=True)# Grace-FO-C 2024----------------------------------------------------------- data_RD_30s = load_all_data("PATHRD30SDATA", 24, 1) #Volle Messreihe GFOC, 2024, RD, 30s samplingtime_30s = data_RD_30s[:, 1]u_sat_RD = data_RD_30s[:, 17]#Gauss-Approach alte Daten und alte Methode-------------------------------master_ele('/PATHRDELEDATA', 'PATHFOLDERSAVEFILE') u_data = np.column_stack((time_30s, u_sat_RD))mjd_interval = [60431, 60492]a_int_data, a_dot_data = master_integrator(u_data, 'PATHFOLDERSAVEFILE_ELEOSC', 'PATHFOLDERSAVEFILE_PCA', mjd_interval)time_a = a_int_data[:, 0]a_gauss = a_int_data[:, 1]time_dadt = a_dot_data[:, 0]#Moving average fÃ¼r dadtwin_len_ma = 94+1     #ganzer Umlauf                                           dadt_gauss = a_dot_data[:, 1]                                                                                                                                dadt_gauss_ma = np.convolve(dadt_gauss, np.ones(win_len_ma)/win_len_ma, mode='same')    ################################################################################################################################## ##################################################################################################################################data_RD_30s = load_all_data("PATHRD30SDATA", 24, 1) #Volle Messreihe GFOC, 2024, RD, 30s samplinga_array = data_RD_30s[:, 20]time_array = data_RD_30s[:, 1]#Plot 1: Amplitudenspektrumamplitudes_full, freqs = fourier_results(a_array, 30)    freq_max = max_freq(amplitudes_full, freqs)periods_plot =1440*1/freqs[1:]amplitudes_plot = amplitudes_full[1:]#Prominente Perioden bestimmenmask = (periods_plot >= 10) & (periods_plot <= 100) #Brereich auf Werte zwischen 10^1 und 10^2 begrenzenperiods_zoom = periods_plot[mask]amplitudes_zoom = amplitudes_plot[mask]peaks, _ = find_peaks(amplitudes_zoom, prominence=45)peak_indices_global = np.where(mask)[0][peaks]print("Gefundene Perioden mit Peaks:")print(periods_plot[peak_indices_global])#Plot 2: Fit-Modell im Vergleich zu Gauss mit Error-Wertenintervalls_per_day = 120                                #12min intervall                                                                                                    intervall_length = 1/intervalls_per_day                 amplitudes, freqs = fourier_results(a_array, 30)        freq_max = max_freq(amplitudes, freqs)# period_osc = [2/freq_max, 1/freq_max] #once and twice per rev# period_osc = [1/freq_max, 2/(3*freq_max)] #twice and three times per rev period_osc = [2/freq_max, 1/freq_max, 2/(3*freq_max)] #once, twice and three times per rev params, fit_values_test, error_fit, error_params = fit_model_error(a_array, time_array, period_osc, constrain_strength=[5*10**5, 10**5], trend_subintervals_per_day=intervalls_per_day, multi_constr=True) subint_count_one_prd = round(len(params[0])/7)    params_two = params[0][:subint_count_one_prd]error_params_two = error_params[0][:subint_count_one_prd]params_three = params[1][:subint_count_one_prd]error_params_three = error_params[1][:subint_count_one_prd]fit_time = np.arange(time_array[0], time_array[len(time_array)-1]+intervall_length, intervall_length)params_two_deriv, fit_time_deriv = cal_deriv(params_two, intervall_length, fit_time) params_three_deriv, _ = cal_deriv(params_three, intervall_length, fit_time) error_params_two_deriv, _ = cal_deriv_error(error_params_two, intervall_length, fit_time) error_params_three_deriv, _ = cal_deriv_error(error_params_three, intervall_length, fit_time) #Plot 3: Einfluss von Mitternacht-Sprung korrigierten Input-Datengrav_data_midnight = load_all_data("PATH5MINOVERLAP10SDATA", 25, 1) #GFOC Daten 8670 Messwerte pro Tag mit je 5 min Overlap am Endeend_day = np.vstack([grav_data_midnight[i*8670 + 8640 : i*8670 + 8670] for i in range(61)])start_day = np.vstack([grav_data_midnight[i*8670 : i*8670 + 30] for i in range(61)])residuals = start_day[:, 20][30:] - end_day[:, 20][:-30]  offsets = residuals.reshape(-1, 30).mean(axis=1)     time_offset = grav_data_midnight[:, 1][::8670][:-1]    grav_data_corrected = offset_correction_overlap(grav_data_midnight[:, 20], 8670, 30, 61)  data_corrected = grav_data_corrected[::3][:77760]intervalls_per_day = 120                                                                                                                           intervall_length = 1/intervalls_per_day                 amplitudes_corrected, freqs = fourier_results(data_corrected, 30)        freq_max = max_freq(amplitudes_corrected, freqs)period_osc = [2/freq_max, 1/freq_max, 2/(3*freq_max)]#Nur eine Oszillation korrigieren (Summe bis 1)params_corrected, _ = fit_model(data_corrected, time_array, period_osc, constrain_strength=[5*10**5], trend_subintervals_per_day=intervalls_per_day, multi_constr=False)    params_two_corrected = params_corrected[:subint_count_one_prd]params_two_corrected_deriv, _ = cal_deriv(params_two_corrected, intervall_length, fit_time)params_corrected_v2, _ = fit_model(data_corrected, time_array, period_osc, constrain_strength=[10**5], trend_subintervals_per_day=intervalls_per_day, multi_constr=False)    params_three_corrected = params_corrected_v2[:subint_count_one_prd]params_three_corrected_deriv, _ = cal_deriv(params_three_corrected, intervall_length, fit_time)###################################################################################################################################Amplitudenspektrum, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) plt.plot(periods_plot, amplitudes_plot, color='blue', linewidth=1)plt.xlabel('Period [min]')plt.ylabel('Amplitude [m]')plt.xscale('log')  plt.yscale('log')plt.grid()plt.show()#Fit-Modell Werte, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Reference (Gaussian approach)", zorder=3)ax.plot(fit_time_deriv, params_two_deriv, linewidth=1, color='blue', label='Fit-model $\dot{\overline{a}}_{\psi_1}$ ($\psi_1 = 5 \cdot 10^5$)', zorder=4)ax.plot(fit_time_deriv, params_three_deriv, linewidth=1, color='darkviolet', label='Fit-model $\dot{\overline{a}}_{\psi_2}$ ($\psi_2 = 10^5$)', zorder=5)ax.fill_between(fit_time_deriv, params_two_deriv - error_params_two_deriv*2*10**-2, params_two_deriv + error_params_two_deriv*2*10**-2, color='royalblue', alpha=0.3, label=r'$\sigma_{\psi_1} \times 2 \cdot 10^{-2}$', zorder=1)ax.fill_between(fit_time_deriv, params_three_deriv - error_params_three_deriv*2*10**-2, params_three_deriv + error_params_three_deriv*2*10**-2, color='plum', alpha=0.4, label=r'$\sigma_{\psi_2} \times 2 \cdot 10^{-2}$', zorder=0)ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [1, 2, 0, 3, 4, 5]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.2),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()#Offsets, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.scatter(time_offset+1, offsets, s=15, color='black', zorder=5) #time_offset+1 um die Position der Differenzen zu verschieben, so z.bsp. max. Offsets bei 10-11 und 11-12 Mai, was stimmt, und nicht 09-10 und 10-11ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel('Offset [m]')ax.grid()plt.show()  #Offset mit Dst index, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4))# Linke Achse (Offset-Punkte)ax.scatter(time_offset + 1, offsets, s=15, color='blue', zorder=3, label='Offset')ax.plot(time_offset + 1, offsets, linewidth=0.5, color='blue', zorder=3)ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_ylim(-1.2, 0.6)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel('Offset [m]')ax.grid()ax.set_axisbelow(True)          # Rechte Achse (Dst index)ax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1],              color='grey', linestyle='--', linewidth=1,              label='Dst index', zorder=1)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)# Achsen-Z-Reihenfolge:ax.set_zorder(2)                ax_right.set_zorder(1)          ax.patch.set_alpha(0.0)         # Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [0, 1]                  handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.05),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()#Mitternachts-Sprung Einfluss, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Reference (Gaussian approach)", zorder=3)ax.plot(fit_time_deriv, params_two_deriv, linewidth=1, color='darkviolet', label='Fit-model $\dot{\overline{a}}_{\psi_1}$ (uncorrected)', zorder=2)ax.plot(fit_time_deriv, params_two_corrected_deriv, linewidth=1, color='blue', label='Fit-model $\dot{\overline{a}}_{\psi_1}$ (offset-corrected)', zorder=1)ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [1, 2, 0, 3]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.2),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()#Mitternachtsprung, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Reference (Gaussian approach)", zorder=3)ax.plot(fit_time_deriv, params_three_deriv, linewidth=1, color='darkviolet', label='Fit-model $\dot{\overline{a}}_{\psi_2}$ (uncorrected)', zorder=2)ax.plot(fit_time_deriv, params_three_corrected_deriv, linewidth=1, color='blue', label='Fit-model $\dot{\overline{a}}_{\psi_2}$ (offset-corrected)', zorder=1)ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [1, 2, 0, 3]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.2),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()