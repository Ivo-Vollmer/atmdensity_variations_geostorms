"""@author: ivovollmer"""import syssys.path.append('PATHTOCODEFUNCTIONS')from gauss_func import *from import_files import *from func_import_air_scalar import *from functions import *from fit_model_error import *from math import *import numpy as npfrom scipy.fft import rfft, rfftfreqfrom scipy.signal import savgol_filterfrom scipy.signal import find_peaksimport matplotlib.pyplot as plt##################################################################################################################################data_weather_2024 = load_all_data("PATHDSTINDEXDATA", 1, 1, csv=True)# Grace-FO-C 2024----------------------------------------------------------- data_RD_30s = load_all_data("PATHRD30SDATA", 24, 1) #Volle Messreihe GFOC, 2024, RD, 30s samplingtime_30s = data_RD_30s[:, 1]u_sat_RD = data_RD_30s[:, 17]#Gauss-Approach alte Daten und alte Methode-------------------------------master_ele('/PATHRDELEDATA', 'PATHFOLDERSAVEFILE') u_data = np.column_stack((time_30s, u_sat_RD))mjd_interval = [60431, 60492]a_int_data, a_dot_data = master_integrator(u_data, 'PATHFOLDERSAVEFILE_ELEOSC', 'PATHFOLDERSAVEFILE_PCA', mjd_interval)time_a = a_int_data[:, 0]a_gauss = a_int_data[:, 1]time_dadt = a_dot_data[:, 0]#Moving average für dadtwin_len_ma = 94+1     #ganzer Umlauf                                           dadt_gauss = a_dot_data[:, 1]                                                                                                                                dadt_gauss_ma = np.convolve(dadt_gauss, np.ones(win_len_ma)/win_len_ma, mode='same')    ##################################################################################################################################data_DYN = load_all_data("PATHDYN30SDATA", 24, 1) #Volle Messreihe GFOC, 2024, DYN#Theorie-Werte und DYN-Datenmu = 3.986004415e14  # Gravitationsparameter Erde mu=G*M_ErdeC_D = 2              # Drag-Koeffizient (absolute Absorption angenommen)Q = 0.995            # Noch anzupassen bei anderen Satellitenm_sat = 600        # Noch anzupassen bei anderen Satelitten data_a_DYN = data_DYN[:, 20]time_30s = data_DYN[:, 1]rho = data_DYN[:, 26]       V_x = data_DYN[:, 30]       V_y = data_DYN[:, 31]       V_z = data_DYN[:, 32]       #DichteModell#7.1-----------------#Berechnung theoretische Veränderung der grossen Halbachse bzgl. Störungsrechnung (Glg. 6.10 auf S.101), dann noch savgoldadt_theo = - (2 * data_a_DYN**2) / mu * (C_D/2 * Q / m_sat) * (np.sqrt(V_x**2 + V_y**2 + V_z**2)**3) * rho * 86400# dadt_theo_savgol = savgol_filter(dadt_theo, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_ma = np.convolve(dadt_theo, np.ones(189)/189, mode='same')dadt_theo_circ = -C_D*Q/m_sat * data_a_DYN**2 * (2 * np.pi /(5665.573770491803))*rho*86400 #n=2*pi/P mit P=Umlaufszeit in Sekunden, hier P=5665.573770491803s=94.4min# dadt_theo_circ_savgol = savgol_filter(dadt_theo_circ, window_length=944, polyorder=3)dadt_theo_circ_ma = np.convolve(dadt_theo_circ, np.ones(189)/189, mode='same')         #----------process_ele_files("PATHDYNELEDATA", 59, "PATHFILEOUTPUTAIRVALUES")air_scalar = np.loadtxt("PATHFILEOUTPUTAIRVALUES")air_scalar_expanded = np.repeat(air_scalar, 2880)rho_scaled = rho*air_scalar_expanded#---------dadt_theo_scaled = - (2 * data_a_DYN**2) / mu * (C_D/2 * Q / m_sat) * (np.sqrt(V_x**2 + V_y**2 + V_z**2)**3) * rho_scaled * 86400# dadt_theo_scaled_savgol = savgol_filter(dadt_theo_scaled, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_scaled_ma = np.convolve(dadt_theo_scaled, np.ones(189)/189, mode='same')dadt_theo_circ_scaled = -C_D*Q/m_sat * data_a_DYN**2 * (2 * np.pi /(5665.573770491803))*rho_scaled*86400 #n=2*pi/P mit P=Umlaufszeit in Sekunden, hier P=5665.573770491803s=94.4min# dadt_theo_circ_scaled_savgol = savgol_filter(dadt_theo_circ_scaled, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_circ_scaled_ma = np.convolve(dadt_theo_circ_scaled, np.ones(189)/189, mode='same')      # ###################################################################################################################################------------------------------------------------------------------------------#Neues Dichtemodell#Berechnung theoretische Veränderung der grossen Halbachse bzgl. Störungsrechnung (Glg. 6.10 auf S.101), dann noch savgoldata_DYN_MSIS_full = load_all_data("PATHDYNMSISDATA", 28, 301) #Volle Messreihe GFOC, 2024, DYN, MSIS-00OXIdata_DYN_MSIS = data_DYN_MSIS_full[::30]data_a_DYN_MSIS = data_DYN_MSIS[:, 20]u_sat_DYN_MSIS = data_DYN_MSIS[:, 17]rho_MSIS = data_DYN_MSIS[:, 26]       V_x_MSIS = data_DYN_MSIS[:, 30]       V_y_MSIS = data_DYN_MSIS[:, 31]       V_z_MSIS = data_DYN_MSIS[:, 32]       dadt_theo_MSIS = - (2 * data_a_DYN_MSIS**2) / mu * (C_D/2 * Q / m_sat) * (np.sqrt(V_x_MSIS**2 + V_y_MSIS**2 + V_z_MSIS**2)**3) * rho_MSIS * 86400# dadt_theo_MSIS_savgol = savgol_filter(dadt_theo_MSIS, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_MSIS_ma =  np.convolve(dadt_theo_MSIS, np.ones(189)/189, mode='same')     dadt_theo_circ_MSIS = -C_D*Q/m_sat * data_a_DYN_MSIS**2 * (2 * np.pi /(5665.573770491803))*rho_MSIS*86400 #n=2*pi/P mit P=Umlaufszeit in Sekunden, hier P=5665.573770491803s=94.4min# dadt_theo_circ_MSIS_savgol = savgol_filter(dadt_theo_circ_MSIS, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_circ_MSIS_ma =  np.convolve(dadt_theo_circ_MSIS, np.ones(189)/189, mode='same')     #----------process_ele_files("PATHDYNELEMSISDATA", 59, "PATHFILEOUTPUTAIRVALUESMSIS")air_scalar_MSIS = np.loadtxt("PATHFILEOUTPUTAIRVALUESMSIS")air_scalar_MSIS_expanded = np.repeat(air_scalar_MSIS, 2880) #2880 da 2880 Messwerte pro Tag in rhorho_MSIS_scaled = rho_MSIS*air_scalar_MSIS_expanded#---------dadt_theo_MSIS_scaled = - (2 * data_a_DYN_MSIS**2) / mu * (C_D/2 * Q / m_sat) * (np.sqrt(V_x_MSIS**2 + V_y_MSIS**2 + V_z_MSIS**2)**3) * rho_MSIS_scaled * 86400# dadt_theo_MSIS_scaled_savgol = savgol_filter(dadt_theo_MSIS_scaled, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_MSIS_scaled_ma = np.convolve(dadt_theo_MSIS_scaled, np.ones(189)/189, mode='same')     dadt_theo_circ_MSIS_scaled = -C_D*Q/m_sat * data_a_DYN_MSIS**2 * (2 * np.pi /(5665.573770491803))*rho_MSIS_scaled*86400 #n=2*pi/P mit P=Umlaufszeit in Sekunden, hier P=5665.573770491803s=94.4min# dadt_theo_circ_MSIS_scaled_savgol = savgol_filter(dadt_theo_circ_MSIS_scaled, window_length=944, polyorder=3) #Fenster über 5 ganze Umläufedadt_theo_circ_MSIS_scaled_ma = np.convolve(dadt_theo_circ_MSIS_scaled, np.ones(189)/189, mode='same')  plt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Reference (Gaussian approach)", zorder=0)ax.plot(time_30s, dadt_theo_ma, color='blue', linewidth=1, label='Unscaled DTM2013 - elliptical orbit')ax.plot(time_30s, dadt_theo_circ_ma, color='lightblue', linewidth=1, label='Unscaled DTM2013 - circular orbit')ax.plot(time_30s, dadt_theo_scaled_ma, color='green', linewidth=1, label='Scaled DTM2013 - elliptical orbit')ax.plot(time_30s, dadt_theo_circ_scaled_ma, color='lightgreen', linewidth=1, label='Scaled DTM2013 - circular orbit')ax.plot(time_30s, dadt_theo_MSIS_ma, color='orange', linewidth=1, label='Unscaled MSIS-00OXI - elliptical orbit')ax.plot(time_30s, dadt_theo_circ_MSIS_ma, color='yellow', linewidth=1, label='Unscaled MSIS-00OXI - circular orbit')ax.plot(time_30s, dadt_theo_MSIS_scaled_ma, color='purple', linewidth=1, label='Scaled MSIS-00OXI - elliptical orbit')ax.plot(time_30s, dadt_theo_circ_MSIS_scaled_ma, color='violet', linewidth=1, label='Scaled MSIS-00OXI - circular orbit')ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [1, 2, 3, 4, 0, 5, 6, 7, 8, 9]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.2),    frameon=False)plt.subplots_adjust(bottom=0.3)plt.show()