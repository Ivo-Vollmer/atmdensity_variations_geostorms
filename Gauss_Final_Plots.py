"""@author: ivovollmer"""import syssys.path.append('PATHTOCODEFUNCTIONS')from gauss_func import *from gauss_e_dgl import *from gauss_r_e_omega_new import *from import_files import *from functions import *from fit_model_error import *from math import *import numpy as npfrom scipy.fft import rfft, rfftfreqfrom scipy.signal import savgol_filterfrom scipy.signal import find_peaksimport matplotlib.pyplot as plt##################################################################################################################################data_weather_2024 = load_all_data("PATHDSTINDEXDATA", 1, 1, csv=True)# Grace-FO-C 2024----------------------------------------------------------- data_RD_30s = load_all_data("PATHRD30SDATA", 24, 1) #Volle Messreihe GFOC, 2024, RD, 30s samplingtime_30s = data_RD_30s[:, 1]u_sat_RD = data_RD_30s[:, 17]#Gauss-Approach alte Daten und alte Methode-------------------------------master_ele('/PATHRDELEDATA', 'PATHFOLDERSAVEFILE') u_data = np.column_stack((time_30s, u_sat_RD))mjd_interval = [60431, 60492]a_int_data, a_dot_data = master_integrator(u_data, 'PATHFOLDERSAVEFILE_ELEOSC', 'PATHFOLDERSAVEFILE_PCA', mjd_interval)time_a = a_int_data[:, 0]a_gauss = a_int_data[:, 1]time_dadt = a_dot_data[:, 0]#Moving average für dadtwin_len_ma = 94+1     #ganzer Umlauf                                           dadt_gauss = a_dot_data[:, 1]                                                                                                                                dadt_gauss_ma = np.convolve(dadt_gauss, np.ones(win_len_ma)/win_len_ma, mode='same')    win_len_ma_half = 47dadt_gauss_ma_half = np.convolve(dadt_gauss, np.ones(win_len_ma_half)/win_len_ma_half, mode='same')    ##################################################################################################################################grav_data = load_all_data("PATHRD30SLSTDATA", 24, 1) #GFOC Daten mit Grav-Beschleunigungenmjd_interval_grav = [grav_data[:, 1][0], grav_data[:, 1][len(grav_data)-1]]grav_time = grav_data[:, 1]u_sat_grav = grav_data[:, 17]u_data_grav =np.column_stack((grav_time, u_sat_grav))a_data_real = grav_data[:, 20]e_data_real = grav_data[:, 21]omega_data_real = grav_data[:, 24]r_data_real = grav_data[:, 11]#Beide Versionen von Gauss anwendena_int_grav_coupled, a_dot_grav_coupled, _, _ =  master_integrator_coupled(u_data_grav, a_data_real, e_data_real, r_data_real, omega_data_real, 'PATHFILE_PCA', mjd_interval_grav)a_int_grav_v2, a_dot_grav_v2 =  master_integrator_v2(u_data_grav, a_data_real, e_data_real, r_data_real, omega_data_real, 'PATHFILE_PCA', mjd_interval_grav)win_len_ma = 94+1#Coupled ODE für etime_a_coupled = a_int_grav_coupled[:, 0]a_gauss_coupled = a_int_grav_coupled[:, 1]time_dadt_coupled = a_dot_grav_coupled[:, 0]                                    dadt_gauss_coupled = a_dot_grav_coupled[:, 1]                                                                                                                                dadt_gauss_coupled_ma = np.convolve(dadt_gauss_coupled, np.ones(win_len_ma)/win_len_ma, mode='same')    #e direkt aus LST verwendettime_a_v2 = a_int_grav_v2[:, 0]a_gauss_v2 = a_int_grav_v2[:, 1]time_dadt_v2 = a_dot_grav_v2[:, 0]                                     dadt_gauss_v2 = a_dot_grav_v2[:, 1]                                                                                                                                dadt_gauss_v2_ma = np.convolve(dadt_gauss_v2, np.ones(win_len_ma)/win_len_ma, mode='same')                 ###################################################################################################################################Plot alle Versionen, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Gaussian approach (baseline)", zorder=0)ax.plot(time_dadt_coupled, dadt_gauss_coupled_ma, linewidth=1, color='blue', label='Gaussian approach (osculating $e$)', zorder=2)ax.plot(time_dadt_v2, dadt_gauss_v2_ma, linewidth=1, color='darkviolet', label='Gaussian approach (coupled ODEs)', zorder=1)ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [1, 2, 0, 3]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=2,    bbox_to_anchor=(0.5, -0.2),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()#Plot Unterschied (Residuen/Differenz a_baseline - a_v2 oder -a_coupled), passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt_coupled, dadt_gauss_ma-dadt_gauss_coupled_ma, linewidth=1, color='red', label='Difference (baseline - osculating $e$)')ax.plot(time_dadt_v2, dadt_gauss_ma-dadt_gauss_v2_ma, linewidth=1, color='blue', label='Difference (baseline - coupled ODEs)')ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-0.275, -0.04)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Legendelines_left, labels_left = ax.get_legend_handles_labels()handles = lines_left labels = labels_leftorder = [0, 1]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=1,    bbox_to_anchor=(0.5, -0.15),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()#da/dt aus Gaussian Approach Baseline mit halbem Orbit als Fensterbreite --> once per rev Störung, passtplt.rcParams["figure.dpi"] = 1000fig, ax = plt.subplots(figsize=(8, 4)) ax.plot(time_dadt, dadt_gauss_ma, linewidth=1, color='red', label="Gaussian approach (baseline, window width = 94 min)")ax.plot(time_dadt, dadt_gauss_ma_half, linewidth=1, color='blue', label="Gaussian approach (baseline, window width = 47 min)")ax.xaxis.set_major_formatter(mjd_to_mmddhh)ax.set_xlim(60440, 60443)ax.set_ylim(-175, 10)ax.set_xlabel('Date and time (mm.dd HH:MM, GPST, 2024)')ax.set_ylabel(r'$\frac{da}{dt} \; \left[ \frac{m}{d} \right]$')ax.grid()#Rechte Achseax_right = ax.twinx()ax_right.plot(data_weather_2024[:, 0], data_weather_2024[:, 1], color='grey', linestyle='--', linewidth=1, label='Dst index', zorder=0)ax_right.set_ylabel('Dst index [nT]')ax_right.set_ylim(-450, 90)#Legendelines_left, labels_left = ax.get_legend_handles_labels()lines_right, labels_right = ax_right.get_legend_handles_labels()handles = lines_left + lines_rightlabels = labels_left + labels_rightorder = [0, 1]handles = [handles[i] for i in order]labels = [labels[i] for i in order]fig.legend(    handles=handles,    labels=labels,    loc='lower center',    ncol=1,    bbox_to_anchor=(0.5, -0.15),    frameon=False)plt.subplots_adjust(bottom=0.2)plt.show()